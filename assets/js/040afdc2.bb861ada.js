"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[31],{8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>s});var t=o(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},8708:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"control-loops/feedback-error-correction-pid","title":"Feedback & Error Correction (PID/Closed-Loop)","description":"Introduction to Closed-Loop Control","source":"@site/docs/control-loops/feedback-error-correction-pid.md","sourceDirName":"control-loops","slug":"/control-loops/feedback-error-correction-pid","permalink":"/docs/control-loops/feedback-error-correction-pid","draft":false,"unlisted":false,"editUrl":"https://github.com/Mohammed-Umair-Kalim/docs/control-loops/feedback-error-correction-pid.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Feedback & Error Correction (PID/Closed-Loop)"},"sidebar":"tutorialSidebar","previous":{"title":"The Physics of Moving (Actuators/Motors)","permalink":"/docs/sensing-actuation/physics-of-moving-actuators-motors"},"next":{"title":"Predictive Control Basics (MPC/Feed-Forward)","permalink":"/docs/control-loops/predictive-control-basics-mpc"}}');var i=o(4848),r=o(8453);const a={sidebar_position:1,title:"Feedback & Error Correction (PID/Closed-Loop)"},s="Feedback & Error Correction (PID/Closed-Loop)",l={},c=[{value:"Introduction to Closed-Loop Control",id:"introduction-to-closed-loop-control",level:2},{value:"The Feedback Control Paradigm",id:"the-feedback-control-paradigm",level:2},{value:"Proportional-Integral-Derivative (PID) Control",id:"proportional-integral-derivative-pid-control",level:2},{value:"Proportional Control",id:"proportional-control",level:3},{value:"Integral Control",id:"integral-control",level:3},{value:"Derivative Control",id:"derivative-control",level:3},{value:"PID Tuning Challenges",id:"pid-tuning-challenges",level:2},{value:"Advanced PID Variants",id:"advanced-pid-variants",level:2},{value:"Cascade PID Control",id:"cascade-pid-control",level:3},{value:"Adaptive PID Control",id:"adaptive-pid-control",level:3},{value:"Implementation Considerations",id:"implementation-considerations",level:2},{value:"Discretization",id:"discretization",level:3},{value:"Saturation and Anti-Windup",id:"saturation-and-anti-windup",level:3},{value:"Filtering",id:"filtering",level:3},{value:"Practical Applications in Robotics",id:"practical-applications-in-robotics",level:2},{value:"Multi-Variable Control Systems",id:"multi-variable-control-systems",level:2},{value:"MIMO Control",id:"mimo-control",level:3},{value:"Cross-Coupling and Interference",id:"cross-coupling-and-interference",level:3},{value:"Robust Control Considerations",id:"robust-control-considerations",level:2},{value:"Uncertainty and Disturbances",id:"uncertainty-and-disturbances",level:3},{value:"Gain Scheduling",id:"gain-scheduling",level:3},{value:"Adaptive and Learning Control",id:"adaptive-and-learning-control",level:2},{value:"Model Reference Adaptive Control (MRAC)",id:"model-reference-adaptive-control-mrac",level:3},{value:"Iterative Learning Control (ILC)",id:"iterative-learning-control-ilc",level:3},{value:"Digital Implementation Challenges",id:"digital-implementation-challenges",level:2},{value:"Sampling Rate Selection",id:"sampling-rate-selection",level:3},{value:"Computational Delay",id:"computational-delay",level:3},{value:"Quantization Effects",id:"quantization-effects",level:3},{value:"Safety and Fault Tolerance",id:"safety-and-fault-tolerance",level:2},{value:"Control Limiting and Saturation Handling",id:"control-limiting-and-saturation-handling",level:3},{value:"Fault Detection and Accommodation",id:"fault-detection-and-accommodation",level:3},{value:"Integration with Higher-Level Planning",id:"integration-with-higher-level-planning",level:2},{value:"Trajectory Generation",id:"trajectory-generation",level:3},{value:"Coordination with Feedforward Control",id:"coordination-with-feedforward-control",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"feedback--error-correction-pidclosed-loop",children:"Feedback & Error Correction (PID/Closed-Loop)"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-closed-loop-control",children:"Introduction to Closed-Loop Control"}),"\n",(0,i.jsx)(n.p,{children:"Closed-loop control systems form the backbone of robotic motion control, enabling precise positioning and trajectory following through continuous feedback and error correction. Unlike open-loop systems that execute pre-planned commands regardless of outcomes, closed-loop controllers continuously monitor system state and adjust commands to minimize errors."}),"\n",(0,i.jsx)(n.h2,{id:"the-feedback-control-paradigm",children:"The Feedback Control Paradigm"}),"\n",(0,i.jsx)(n.p,{children:"In Physical AI systems, feedback control creates a continuous cycle of sensing, decision-making, and actuation. The controller compares desired system behavior with actual measured behavior, computes the error, and generates corrective actions. This process occurs at high frequencies, often hundreds or thousands of times per second in modern robotic systems."}),"\n",(0,i.jsx)(n.p,{children:"The fundamental feedback control equation is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Control Output = Controller(Estimated State - Desired State)\n"})}),"\n",(0,i.jsx)(n.p,{children:"This simple relationship enables complex behaviors by continuously correcting deviations from desired trajectories."}),"\n",(0,i.jsx)(n.h2,{id:"proportional-integral-derivative-pid-control",children:"Proportional-Integral-Derivative (PID) Control"}),"\n",(0,i.jsx)(n.p,{children:"PID control is the most widely used feedback control algorithm in robotics due to its simplicity and effectiveness. Each component serves a distinct purpose:"}),"\n",(0,i.jsx)(n.h3,{id:"proportional-control",children:"Proportional Control"}),"\n",(0,i.jsx)(n.p,{children:"The proportional term provides immediate response to error by applying corrective force proportional to error magnitude. Larger errors generate larger corrective forces. However, pure proportional control often results in steady-state error where the system settles near but not exactly at the target."}),"\n",(0,i.jsx)(n.h3,{id:"integral-control",children:"Integral Control"}),"\n",(0,i.jsx)(n.p,{children:"The integral term accumulates past errors over time, eliminating steady-state error by generating corrective action based on the history of errors. This ensures that even small persistent errors are eventually corrected, though it can lead to overshoot if not properly tuned."}),"\n",(0,i.jsx)(n.h3,{id:"derivative-control",children:"Derivative Control"}),"\n",(0,i.jsx)(n.p,{children:'The derivative term predicts future error based on the rate of error change, providing damping to reduce overshoot and oscillation. It acts as a "braking" force that opposes rapid changes, improving system stability.'}),"\n",(0,i.jsx)(n.h2,{id:"pid-tuning-challenges",children:"PID Tuning Challenges"}),"\n",(0,i.jsx)(n.p,{children:"Proper PID tuning requires balancing competing objectives. High proportional gains provide fast response but can cause oscillation. High integral gains eliminate steady-state error but may cause overshoot and instability. High derivative gains improve stability but amplify sensor noise."}),"\n",(0,i.jsx)(n.p,{children:"Ziegler-Nichols and other systematic tuning methods provide starting points, but final tuning often requires iterative adjustment based on system response to achieve optimal performance for specific applications."}),"\n",(0,i.jsx)(n.h2,{id:"advanced-pid-variants",children:"Advanced PID Variants"}),"\n",(0,i.jsx)(n.h3,{id:"cascade-pid-control",children:"Cascade PID Control"}),"\n",(0,i.jsx)(n.p,{children:"In robotic systems with multiple control objectives, cascade PID control uses multiple PID controllers in series. For example, a position controller might command velocity to a velocity controller, which in turn commands torque to a torque controller. This hierarchical approach provides better performance than single-loop control."}),"\n",(0,i.jsx)(n.h3,{id:"adaptive-pid-control",children:"Adaptive PID Control"}),"\n",(0,i.jsx)(n.p,{children:"Adaptive PID controllers adjust their parameters in real-time based on changing system dynamics. This is particularly valuable in Physical AI systems where payloads, friction, or other parameters may change during operation."}),"\n",(0,i.jsx)(n.h2,{id:"implementation-considerations",children:"Implementation Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"discretization",children:"Discretization"}),"\n",(0,i.jsx)(n.p,{children:"Digital implementations of PID control require discretization of the continuous-time equations. The derivative term is typically approximated using backward difference, while the integral is computed using numerical integration methods like the trapezoidal rule."}),"\n",(0,i.jsx)(n.h3,{id:"saturation-and-anti-windup",children:"Saturation and Anti-Windup"}),"\n",(0,i.jsx)(n.p,{children:"Actuator saturation occurs when the controller commands exceed physical limits. Integral windup can cause severe overshoot when the system finally moves back into the controllable region. Anti-windup strategies limit integral action when saturation occurs."}),"\n",(0,i.jsx)(n.h3,{id:"filtering",children:"Filtering"}),"\n",(0,i.jsx)(n.p,{children:"Sensor noise can cause excessive control activity, particularly in the derivative term. Low-pass filtering of sensor signals or derivative filtering can reduce noise effects while maintaining control performance."}),"\n",(0,i.jsx)(n.h2,{id:"practical-applications-in-robotics",children:"Practical Applications in Robotics"}),"\n",(0,i.jsx)(n.p,{children:"PID controllers are ubiquitous in robotics, controlling joint positions, end-effector trajectories, and system velocities. Modern robotic controllers often combine PID with feedforward terms to account for known dynamics, creating more sophisticated control architectures while maintaining the intuitive PID framework."}),"\n",(0,i.jsx)(n.h2,{id:"multi-variable-control-systems",children:"Multi-Variable Control Systems"}),"\n",(0,i.jsx)(n.h3,{id:"mimo-control",children:"MIMO Control"}),"\n",(0,i.jsx)(n.p,{children:"Most robotic systems are multi-input, multi-output (MIMO) systems where multiple control inputs affect multiple outputs simultaneously. In a robotic arm, for example, the torque applied at one joint affects the motion of all downstream joints due to dynamic coupling. Proper MIMO control must account for these interactions to achieve coordinated motion."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Decentralized Control"}),": Independent PID controllers for each joint, ignoring coupling effects. Simple to implement but may result in suboptimal performance for highly coupled systems."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Centralized Control"}),": A single controller that considers all system interactions simultaneously. Provides optimal performance but increases complexity and computational requirements."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Feedforward Compensation"}),": Adding feedforward terms to compensate for known coupling effects while maintaining simple feedback controllers."]}),"\n",(0,i.jsx)(n.h3,{id:"cross-coupling-and-interference",children:"Cross-Coupling and Interference"}),"\n",(0,i.jsx)(n.p,{children:"In multi-joint robotic systems, motion of one joint creates forces and torques on other joints through dynamic coupling. This cross-coupling can cause unwanted motion when only a subset of joints is commanded to move. Advanced control strategies must account for these interactions to achieve precise coordinated motion."}),"\n",(0,i.jsx)(n.h2,{id:"robust-control-considerations",children:"Robust Control Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"uncertainty-and-disturbances",children:"Uncertainty and Disturbances"}),"\n",(0,i.jsx)(n.p,{children:"Real robotic systems are subject to various uncertainties:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Parametric uncertainty: Errors in known system parameters like mass, inertia, or friction coefficients"}),"\n",(0,i.jsx)(n.li,{children:"Unmodeled dynamics: System behaviors not captured in the control model"}),"\n",(0,i.jsx)(n.li,{children:"External disturbances: Forces from the environment or other external sources"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Robust control techniques ensure stable performance despite these uncertainties by designing controllers that maintain performance over a range of possible system behaviors."}),"\n",(0,i.jsx)(n.h3,{id:"gain-scheduling",children:"Gain Scheduling"}),"\n",(0,i.jsx)(n.p,{children:"Gain scheduling adjusts controller parameters based on operating conditions such as robot configuration, payload, or environmental conditions. This approach provides good performance across a wide range of conditions while maintaining the simplicity of linear control techniques."}),"\n",(0,i.jsx)(n.h2,{id:"adaptive-and-learning-control",children:"Adaptive and Learning Control"}),"\n",(0,i.jsx)(n.h3,{id:"model-reference-adaptive-control-mrac",children:"Model Reference Adaptive Control (MRAC)"}),"\n",(0,i.jsx)(n.p,{children:"MRAC adjusts controller parameters to make the closed-loop system behave like a desired reference model. The adaptation law continuously updates parameters based on the difference between actual and desired behavior, providing robustness to parametric uncertainties."}),"\n",(0,i.jsx)(n.h3,{id:"iterative-learning-control-ilc",children:"Iterative Learning Control (ILC)"}),"\n",(0,i.jsx)(n.p,{children:"For repetitive tasks, Iterative Learning Control improves performance over successive trials by learning from previous execution errors. The learned corrections are added to the feedback control to improve tracking performance on future iterations of the same task."}),"\n",(0,i.jsx)(n.h2,{id:"digital-implementation-challenges",children:"Digital Implementation Challenges"}),"\n",(0,i.jsx)(n.h3,{id:"sampling-rate-selection",children:"Sampling Rate Selection"}),"\n",(0,i.jsx)(n.p,{children:"The choice of control loop update rate affects both performance and computational requirements. Higher sampling rates provide better performance by reducing the effects of discretization, but require more computational resources and may amplify sensor noise. The sampling rate should be chosen based on the system bandwidth and desired performance."}),"\n",(0,i.jsx)(n.h3,{id:"computational-delay",children:"Computational Delay"}),"\n",(0,i.jsx)(n.p,{children:"In digital control systems, there is a delay between sensing and actuation due to computational processing time. This delay can affect system stability and performance, particularly in high-bandwidth control systems. Compensation techniques may be required to account for these delays."}),"\n",(0,i.jsx)(n.h3,{id:"quantization-effects",children:"Quantization Effects"}),"\n",(0,i.jsx)(n.p,{children:"Digital systems have limited resolution in both sensing and actuation. Quantization of sensor measurements can cause limit cycles and steady-state errors, particularly in systems with high-resolution requirements. Proper design must account for these effects to maintain performance."}),"\n",(0,i.jsx)(n.h2,{id:"safety-and-fault-tolerance",children:"Safety and Fault Tolerance"}),"\n",(0,i.jsx)(n.h3,{id:"control-limiting-and-saturation-handling",children:"Control Limiting and Saturation Handling"}),"\n",(0,i.jsx)(n.p,{children:"Physical systems have limits on forces, velocities, accelerations, and other quantities. Control systems must handle these limits appropriately to prevent damage and maintain safety. Techniques include:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Command shaping"}),": Modifying reference commands to prevent limit violations\n",(0,i.jsx)(n.strong,{children:"Control allocation"}),": Distributing control effort among redundant actuators to stay within individual limits\n",(0,i.jsx)(n.strong,{children:"Saturation recovery"}),": Strategies to recover from saturation conditions without causing instability"]}),"\n",(0,i.jsx)(n.h3,{id:"fault-detection-and-accommodation",children:"Fault Detection and Accommodation"}),"\n",(0,i.jsx)(n.p,{children:"Robotic systems must detect and accommodate various types of faults including sensor failures, actuator failures, and mechanical problems. Fault-tolerant control systems maintain acceptable performance despite component failures through:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Analytical redundancy"}),": Using system models to detect inconsistencies in sensor data\n",(0,i.jsx)(n.strong,{children:"Hardware redundancy"}),": Multiple sensors or actuators that can take over when primary components fail\n",(0,i.jsx)(n.strong,{children:"Reconfigurable control"}),": Controllers that can adapt their structure based on available components"]}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-higher-level-planning",children:"Integration with Higher-Level Planning"}),"\n",(0,i.jsx)(n.h3,{id:"trajectory-generation",children:"Trajectory Generation"}),"\n",(0,i.jsx)(n.p,{children:"The performance of feedback controllers depends heavily on the quality of reference trajectories. Trajectory generation must consider system dynamics, constraints, and the capabilities of the feedback controller to generate feasible and optimal paths."}),"\n",(0,i.jsx)(n.h3,{id:"coordination-with-feedforward-control",children:"Coordination with Feedforward Control"}),"\n",(0,i.jsx)(n.p,{children:"Feedback controllers work best when combined with feedforward control that handles the predictable aspects of system behavior. The feedback controller then only needs to handle disturbances and model errors, leading to improved performance and reduced control effort."}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Feedback control through PID algorithms provides the foundation for precise robotic motion control. Understanding the balance between proportional, integral, and derivative terms, along with implementation considerations, is essential for developing effective Physical AI systems. The next section will explore predictive control methods that complement feedback approaches."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);