"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[383],{7926:(i,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"control-loops/predictive-control-basics-mpc","title":"Predictive Control Basics (MPC/Feed-Forward)","description":"Introduction to Predictive Control","source":"@site/docs/control-loops/predictive-control-basics-mpc.md","sourceDirName":"control-loops","slug":"/control-loops/predictive-control-basics-mpc","permalink":"/docs/control-loops/predictive-control-basics-mpc","draft":false,"unlisted":false,"editUrl":"https://github.com/Mohammed-Umair-Kalim/docs/control-loops/predictive-control-basics-mpc.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Predictive Control Basics (MPC/Feed-Forward)"},"sidebar":"tutorialSidebar","previous":{"title":"Feedback & Error Correction (PID/Closed-Loop)","permalink":"/docs/control-loops/feedback-error-correction-pid"},"next":{"title":"Contact Dynamics & Friction","permalink":"/docs/physical-interaction/contact-dynamics-friction"}}');var o=n(4848),r=n(8453);const a={sidebar_position:2,title:"Predictive Control Basics (MPC/Feed-Forward)"},s="Predictive Control Basics (MPC/Feed-Forward)",c={},l=[{value:"Introduction to Predictive Control",id:"introduction-to-predictive-control",level:2},{value:"Feed-Forward Control Principles",id:"feed-forward-control-principles",level:2},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:2},{value:"Prediction Horizon",id:"prediction-horizon",level:3},{value:"Control Horizon",id:"control-horizon",level:3},{value:"Cost Function Design",id:"cost-function-design",level:3},{value:"Implementation Challenges",id:"implementation-challenges",level:2},{value:"Computational Complexity",id:"computational-complexity",level:3},{value:"Model Accuracy",id:"model-accuracy",level:3},{value:"Constraint Handling",id:"constraint-handling",level:3},{value:"Integration with Feedback Control",id:"integration-with-feedback-control",level:2},{value:"Advanced Predictive Techniques",id:"advanced-predictive-techniques",level:2},{value:"Adaptive Predictive Control",id:"adaptive-predictive-control",level:3},{value:"Stochastic MPC",id:"stochastic-mpc",level:3},{value:"Applications in Physical AI",id:"applications-in-physical-ai",level:2},{value:"Nonlinear Model Predictive Control (NMPC)",id:"nonlinear-model-predictive-control-nmpc",level:2},{value:"Formulation and Solution",id:"formulation-and-solution",level:3},{value:"Solution Methods",id:"solution-methods",level:3},{value:"Economic Model Predictive Control (EMPC)",id:"economic-model-predictive-control-empc",level:2},{value:"Robust and Stochastic MPC",id:"robust-and-stochastic-mpc",level:2},{value:"Robust MPC",id:"robust-mpc",level:3},{value:"Stochastic MPC",id:"stochastic-mpc-1",level:3},{value:"Implementation Considerations",id:"implementation-considerations",level:2},{value:"Real-Time Optimization",id:"real-time-optimization",level:3},{value:"Model Identification and Updating",id:"model-identification-and-updating",level:3},{value:"Constraint Handling Strategies",id:"constraint-handling-strategies",level:2},{value:"Soft vs. Hard Constraints",id:"soft-vs-hard-constraints",level:3},{value:"Constraint Prioritization",id:"constraint-prioritization",level:3},{value:"Applications in Complex Robotic Systems",id:"applications-in-complex-robotic-systems",level:2},{value:"Legged Locomotion",id:"legged-locomotion",level:3},{value:"Multi-Robot Coordination",id:"multi-robot-coordination",level:3},{value:"Manipulation with Contacts",id:"manipulation-with-contacts",level:3},{value:"Integration with Learning",id:"integration-with-learning",level:2},{value:"Learning-Based MPC",id:"learning-based-mpc",level:3},{value:"Adaptive MPC",id:"adaptive-mpc",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(i){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...i.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"predictive-control-basics-mpcfeed-forward",children:"Predictive Control Basics (MPC/Feed-Forward)"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-predictive-control",children:"Introduction to Predictive Control"}),"\n",(0,o.jsx)(e.p,{children:"While feedback control systems react to errors after they occur, predictive control systems anticipate future behavior and proactively adjust control actions. Model Predictive Control (MPC) and feed-forward control represent forward-looking approaches that leverage system models to improve performance beyond what feedback alone can achieve."}),"\n",(0,o.jsx)(e.h2,{id:"feed-forward-control-principles",children:"Feed-Forward Control Principles"}),"\n",(0,o.jsx)(e.p,{children:"Feed-forward control generates control actions based on anticipated disturbances or desired trajectories rather than measured errors. For a robotic manipulator following a trajectory, feed-forward control computes the required torques based on the planned path kinematics and dynamics, providing the majority of the control effort while feedback control handles unmodeled dynamics and disturbances."}),"\n",(0,o.jsx)(e.p,{children:"The feed-forward control equation takes the form:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Feed-forward Command = Inverse Model(Desired Trajectory)\n"})}),"\n",(0,o.jsx)(e.p,{children:"For robotic systems, this often involves inverse kinematics and inverse dynamics calculations to determine required joint torques for desired motions."}),"\n",(0,o.jsx)(e.h2,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,o.jsx)(e.p,{children:"MPC represents a more sophisticated predictive approach that solves an optimization problem at each control step. The controller uses a model of system dynamics to predict future behavior over a finite horizon, then optimizes control actions to minimize a cost function while satisfying constraints."}),"\n",(0,o.jsx)(e.h3,{id:"prediction-horizon",children:"Prediction Horizon"}),"\n",(0,o.jsx)(e.p,{children:"The prediction horizon determines how far into the future the controller considers. Longer horizons provide better anticipation of future events but increase computational complexity. Shorter horizons reduce computation time but may miss important future constraints or disturbances."}),"\n",(0,o.jsx)(e.h3,{id:"control-horizon",children:"Control Horizon"}),"\n",(0,o.jsx)(e.p,{children:"The control horizon specifies how many control moves are optimized at each step. Often shorter than the prediction horizon, this parameter affects the controller's aggressiveness and computational requirements."}),"\n",(0,o.jsx)(e.h3,{id:"cost-function-design",children:"Cost Function Design"}),"\n",(0,o.jsx)(e.p,{children:"The cost function weights different objectives such as tracking error, control effort, and constraint violations. Proper weighting is critical for achieving desired performance while maintaining system stability and constraint satisfaction."}),"\n",(0,o.jsx)(e.h2,{id:"implementation-challenges",children:"Implementation Challenges"}),"\n",(0,o.jsx)(e.h3,{id:"computational-complexity",children:"Computational Complexity"}),"\n",(0,o.jsx)(e.p,{children:"MPC requires solving optimization problems in real-time, making it computationally intensive. For robotic systems with fast dynamics, this may require specialized optimization algorithms or simplified models to meet timing constraints."}),"\n",(0,o.jsx)(e.h3,{id:"model-accuracy",children:"Model Accuracy"}),"\n",(0,o.jsx)(e.p,{children:"Predictive controllers depend heavily on accurate system models. Model uncertainty can degrade performance or cause instability. Robust MPC approaches account for model uncertainty but may result in conservative control actions."}),"\n",(0,o.jsx)(e.h3,{id:"constraint-handling",children:"Constraint Handling"}),"\n",(0,o.jsx)(e.p,{children:"One of MPC's key advantages is explicit constraint handling. However, formulating appropriate constraints for complex robotic systems can be challenging, and constraint conflicts must be resolved appropriately."}),"\n",(0,o.jsx)(e.h2,{id:"integration-with-feedback-control",children:"Integration with Feedback Control"}),"\n",(0,o.jsx)(e.p,{children:"Pure feed-forward control requires perfect models and no disturbances, making it impractical alone. Modern robotic systems typically combine feed-forward and feedback approaches, with feed-forward providing the primary control action and feedback handling errors and disturbances."}),"\n",(0,o.jsx)(e.p,{children:"In MPC, feedback is incorporated through the receding horizon principle, where the controller solves the optimization problem repeatedly using updated state measurements. This provides robustness to modeling errors and disturbances while maintaining the predictive benefits."}),"\n",(0,o.jsx)(e.h2,{id:"advanced-predictive-techniques",children:"Advanced Predictive Techniques"}),"\n",(0,o.jsx)(e.h3,{id:"adaptive-predictive-control",children:"Adaptive Predictive Control"}),"\n",(0,o.jsx)(e.p,{children:"Adaptive approaches update the internal model based on observed system behavior, improving prediction accuracy over time. This is particularly valuable for systems with slowly changing dynamics or initially uncertain parameters."}),"\n",(0,o.jsx)(e.h3,{id:"stochastic-mpc",children:"Stochastic MPC"}),"\n",(0,o.jsx)(e.p,{children:"Stochastic MPC accounts for uncertainty in system dynamics and disturbances by incorporating probabilistic models. This approach optimizes expected performance while maintaining constraint satisfaction with specified probability levels."}),"\n",(0,o.jsx)(e.h2,{id:"applications-in-physical-ai",children:"Applications in Physical AI"}),"\n",(0,o.jsx)(e.p,{children:"Predictive control is particularly valuable in Physical AI systems where future events can be anticipated, such as walking robots that must plan foot placements or manipulator systems that must avoid collisions while achieving goals. The ability to explicitly handle constraints makes predictive control attractive for safety-critical applications."}),"\n",(0,o.jsx)(e.h2,{id:"nonlinear-model-predictive-control-nmpc",children:"Nonlinear Model Predictive Control (NMPC)"}),"\n",(0,o.jsx)(e.h3,{id:"formulation-and-solution",children:"Formulation and Solution"}),"\n",(0,o.jsx)(e.p,{children:"Nonlinear Model Predictive Control handles systems with significant nonlinearities that cannot be adequately addressed by linear approximations. The optimization problem in NMPC is formulated using the full nonlinear system model:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"min \u2211(l(x\u2096, u\u2096) + V_f(x_N))\ns.t. x\u2096\u208a\u2081 = f(x\u2096, u\u2096)\n     g(x\u2096, u\u2096) \u2264 0\n     x\u2080 = measured state\n"})}),"\n",(0,o.jsx)(e.p,{children:"Where f represents the nonlinear system dynamics, l is the stage cost, and V_f is the terminal cost."}),"\n",(0,o.jsx)(e.h3,{id:"solution-methods",children:"Solution Methods"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Sequential Quadratic Programming (SQP)"}),": Solves a sequence of quadratic programming subproblems to handle the nonlinear optimization."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Multiple Shooting"}),": Divides the prediction horizon into multiple intervals, solving for state and control trajectories simultaneously to improve numerical conditioning."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Direct Collocation"}),": Transcribes the continuous-time optimal control problem into a finite-dimensional nonlinear program using polynomial approximations."]}),"\n",(0,o.jsx)(e.h2,{id:"economic-model-predictive-control-empc",children:"Economic Model Predictive Control (EMPC)"}),"\n",(0,o.jsx)(e.p,{children:"Traditional MPC formulations focus on tracking reference trajectories or regulating to equilibrium points. Economic MPC directly optimizes economic objectives such as energy consumption, productivity, or other performance metrics of interest. This approach is particularly valuable in Physical AI systems where operational efficiency is critical."}),"\n",(0,o.jsx)(e.p,{children:"EMPC formulations typically consider:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Operational cost minimization"}),"\n",(0,o.jsx)(e.li,{children:"Resource utilization optimization"}),"\n",(0,o.jsx)(e.li,{children:"Long-term performance objectives"}),"\n",(0,o.jsx)(e.li,{children:"Environmental impact considerations"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"robust-and-stochastic-mpc",children:"Robust and Stochastic MPC"}),"\n",(0,o.jsx)(e.h3,{id:"robust-mpc",children:"Robust MPC"}),"\n",(0,o.jsx)(e.p,{children:"Robust MPC explicitly accounts for model uncertainty and disturbances by designing controllers that maintain performance and constraint satisfaction for all possible uncertainty realizations within a specified set. Common approaches include:"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Min-max optimization"}),": Optimizes the worst-case performance over the uncertainty set\n",(0,o.jsx)(e.strong,{children:"Tube-based MPC"}),": Maintains the actual trajectory within a tube around the nominal trajectory\n",(0,o.jsx)(e.strong,{children:"Constraint tightening"}),": Adjusts constraints to account for uncertainty effects"]}),"\n",(0,o.jsx)(e.h3,{id:"stochastic-mpc-1",children:"Stochastic MPC"}),"\n",(0,o.jsx)(e.p,{children:"Stochastic MPC treats uncertainty as random variables with known probability distributions. This approach allows for less conservative control while maintaining probabilistic guarantees on constraint satisfaction."}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Chance constraints"}),": Allow constraint violation with specified probability\n",(0,o.jsx)(e.strong,{children:"Scenario-based approaches"}),": Optimize over multiple uncertainty realizations\n",(0,o.jsx)(e.strong,{children:"Polynomial chaos expansions"}),": Represent uncertainty using orthogonal polynomial expansions"]}),"\n",(0,o.jsx)(e.h2,{id:"implementation-considerations",children:"Implementation Considerations"}),"\n",(0,o.jsx)(e.h3,{id:"real-time-optimization",children:"Real-Time Optimization"}),"\n",(0,o.jsx)(e.p,{children:"MPC's computational requirements can be significant, especially for fast robotic systems. Implementation strategies include:"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Warm starting"}),": Using previous solution as initial guess for current optimization\n",(0,o.jsx)(e.strong,{children:"Early termination"}),": Stopping optimization after a fixed time or iteration limit\n",(0,o.jsx)(e.strong,{children:"Simplified models"}),": Using reduced-order models for prediction while maintaining tracking of full-order model\n",(0,o.jsx)(e.strong,{children:"Parallel computing"}),": Exploiting parallel computation for optimization algorithms"]}),"\n",(0,o.jsx)(e.h3,{id:"model-identification-and-updating",children:"Model Identification and Updating"}),"\n",(0,o.jsx)(e.p,{children:"The performance of predictive controllers heavily depends on model quality. Approaches for obtaining and maintaining accurate models include:"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"System identification"}),": Using experimental data to estimate model parameters\n",(0,o.jsx)(e.strong,{children:"Online parameter estimation"}),": Continuously updating model parameters based on recent data\n",(0,o.jsx)(e.strong,{children:"Machine learning integration"}),": Using neural networks or other learning methods to capture unmodeled dynamics"]}),"\n",(0,o.jsx)(e.h2,{id:"constraint-handling-strategies",children:"Constraint Handling Strategies"}),"\n",(0,o.jsx)(e.h3,{id:"soft-vs-hard-constraints",children:"Soft vs. Hard Constraints"}),"\n",(0,o.jsx)(e.p,{children:"Hard constraints must always be satisfied, potentially leading to infeasible optimization problems. Soft constraints allow limited violations with penalty costs, ensuring feasibility at the cost of constraint satisfaction guarantees."}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Exact penalty functions"}),": Add penalty terms that become infinite at constraint boundaries\n",(0,o.jsx)(e.strong,{children:"Barrier methods"}),": Use functions that approach infinity as constraints are approached\n",(0,o.jsx)(e.strong,{children:"Augmented Lagrangian methods"}),": Combine Lagrangian and penalty approaches"]}),"\n",(0,o.jsx)(e.h3,{id:"constraint-prioritization",children:"Constraint Prioritization"}),"\n",(0,o.jsx)(e.p,{children:"In over-constrained situations, different constraints may have different priorities:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Safety constraints (highest priority)"}),"\n",(0,o.jsx)(e.li,{children:"Physical limits (high priority)"}),"\n",(0,o.jsx)(e.li,{children:"Performance constraints (medium priority)"}),"\n",(0,o.jsx)(e.li,{children:"Economic objectives (lower priority)"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"applications-in-complex-robotic-systems",children:"Applications in Complex Robotic Systems"}),"\n",(0,o.jsx)(e.h3,{id:"legged-locomotion",children:"Legged Locomotion"}),"\n",(0,o.jsx)(e.p,{children:"MPC is particularly effective for legged robot locomotion, where contact constraints and gait patterns must be optimized simultaneously. The predictive nature allows planning of future foot placements while maintaining balance and achieving desired locomotion speeds."}),"\n",(0,o.jsx)(e.h3,{id:"multi-robot-coordination",children:"Multi-Robot Coordination"}),"\n",(0,o.jsx)(e.p,{children:"Predictive control frameworks naturally handle coordination between multiple robots by including other robots' predicted behaviors in the optimization problem. This enables collision avoidance, formation control, and task allocation."}),"\n",(0,o.jsx)(e.h3,{id:"manipulation-with-contacts",children:"Manipulation with Contacts"}),"\n",(0,o.jsx)(e.p,{children:"For robotic manipulation involving contacts with objects, MPC can optimize both motion and contact forces simultaneously, handling the hybrid nature of contact and free motion within a unified framework."}),"\n",(0,o.jsx)(e.h2,{id:"integration-with-learning",children:"Integration with Learning"}),"\n",(0,o.jsx)(e.h3,{id:"learning-based-mpc",children:"Learning-Based MPC"}),"\n",(0,o.jsx)(e.p,{children:"Machine learning techniques can enhance MPC performance by:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Learning system models from data"}),"\n",(0,o.jsx)(e.li,{children:"Learning cost functions from expert demonstrations"}),"\n",(0,o.jsx)(e.li,{children:"Learning terminal costs and constraints for stability"}),"\n",(0,o.jsx)(e.li,{children:"Learning optimization algorithms tailored to specific problems"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"adaptive-mpc",children:"Adaptive MPC"}),"\n",(0,o.jsx)(e.p,{children:"Adaptive MPC combines system identification with predictive control, continuously updating models based on observed behavior and adjusting control actions accordingly. This approach provides robustness to changing system dynamics while maintaining the predictive benefits."}),"\n",(0,o.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(e.p,{children:"Predictive control techniques complement feedback approaches by providing proactive control actions based on system models and anticipated behavior. While computationally more demanding than simple feedback control, predictive methods enable superior performance in many Physical AI applications. The integration of predictive and feedback approaches provides robust performance across a wide range of operating conditions."})]})}function p(i={}){const{wrapper:e}={...(0,r.R)(),...i.components};return e?(0,o.jsx)(e,{...i,children:(0,o.jsx)(d,{...i})}):d(i)}},8453:(i,e,n)=>{n.d(e,{R:()=>a,x:()=>s});var t=n(6540);const o={},r=t.createContext(o);function a(i){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof i?i(e):{...e,...i}},[e,i])}function s(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(o):i.components||o:a(i.components),t.createElement(r.Provider,{value:e},i.children)}}}]);